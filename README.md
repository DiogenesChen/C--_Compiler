# C--_Compiler Final\_project


## 一. 目标

1. 背景知识介绍

C-- 语言是本实验的源语言. 是一个 c 语言的子集, C-- 语言是单文件的, 去除了 C 语言中的 include/define/pointer/struct 等较复杂特性. LLVM 是一个模块化的, 可重用的编译器和工具链的集合, 目的是提供一个现代的, 基于 SSA 的, 能够支持任意静态和动态编译的编程语言的编译策略. 在最近几年已经成为表现上能够和 gcc 对标的项目. LLVM IR 是 LLVM 项目中通用的中间代码, 作为源语言和体系架构的连接部分, 是学生需要从源语言中编译并翻译到的目标语言. 

2. 大作业要求
本次大作业要求编写一个编译器前端(包括词法分析器, 语法分析器, 语义分析及中间代码生成), 
+ (1)【必做】使用自动机理论编写词法分析器.
	编写C--语言的词法分析器, 理解词法分析器的工作原理, 熟练掌握基于自动机理论的词法分析器的工作流程. 编写源代码识别输出单词的二元属性, 填写符号表. 
+ (2)【必做】自上而下或者自下而上的语法分析方法编写语法分析器. 
	编写C--语言的语法分析器, 理解自上而下/自下而上的语法分析算法的工作原理；理解词法分析与语法分析之间的关系. 语法分析器的输入为 C--语言源代码,  输出为按扫描顺序进行推导或归约的正确/错误的判别结果, 以及按照最左推导顺序/规范规约顺序生成语法树所用的产生式序列. 
+ (3)【选做】补充完成中间代码生成部分代码. 
	补全给出的中间代码生成部分代码. 将编译器的前端与我们提供的编译器中端衔接, 该部分需要遍历语法分析器生成的语法树, 访问语法树结点并调用我们所提供的中端代码(见附录 2.2), 最终输出中间代码.

![](https://s1.ax1x.com/2023/05/12/p9svvgU.png)

## 二. 软件需求

本次大作业要求实现的词法分析器和语法分析器可以组成一个完整的编译流程, 即针对输入的C--语言, 可以按照上面的流程图, 给出词法分析器的单词符号序列和语法分析器的产生式序列. 选做任务不要求融合进编译流程. 

1. 词法分析器(必做)
	1. 	完成 C--语言的词法分析器, 要求采用课程教授方法, 实现有限自动机确定化, 最小化算法. 词法分析器的输入为 C--语言源代码, 输出识别出单词的二元属性, 填写符号表. 单词符号的类型及具体要求如下
	> 单词的二元属性, 填写符号表. 单词符号的类型及具体要求
	> + 关键字(KW, 不区分大小写)包括: int, void, return, const
	> + 运算符(OP)包括: +, -, \*, /, %, \=, \>, <, \==, <=, \>=, !=, &&, ||
	> + 界符(SE)包括: (, ), {, }, ;, ,

	2. 实现语言: C/C++/Java/Python. 注意: 中端代码为 C++编写, 若决定做选做部分,  推荐首选 C++. 
	3. 操作目的: 生成符号表；将源代码转化为单词符号序列. 
	4. 输出: 请严格按照第三章“输出示例”的格式要求, 将结果保存为文本文件(.txt). 

标识符(IDN)定义与 C 语言保持相同, 为字母, 数字和下划线(\_)组成的不以数字开头的串. 为方便起见, 本次作业中定义“main”也属于标识符. 标识符的正则表达式为: IDN=\[a‐zA‐Z\_][a‐zA‐Z_0‐9]\* 

整数(INT)定义与 C 语言类似. 为方便起见, 本次作业中定义整数包含负数. 整数的正则表达式为INT=-?(0 | \[1-9][0-9]\*)

2. 语法分析器(必做)
	1. 完成 C--语言的语法分析器, 语法分析器的输入为 C--语言代码的单词符号序列(即语法分析器的输出), 输出用最左推导或规范规约产生语法树所用的产生式序列. C--语言文法会包含以下操作: 
		1. 常量定义的声明(int a;)
		2. 常量定义的初始化(int a = 3;)
		3. 常类型数据的声明和定义(const int a = 3;)
		4. 变量赋值传递(已声明的情况)(a = 3;/a = b;)
		5. 函数名称, 返回值类型, 函数内部建立初始基本块并插入返回指令(int add(...))
		6. 函数传入参数的创建, 管理(int add(int a, int b))
		7. 一元运算表达式(加法和乘法), (int a = 3 + 4; int c = a * b;)
		8. 单目运算符号和变量数值结合(+/-/!)(!0/-3)
		9. 复合运算表达式(多个一元表达式结合 a = (b + c) * d)
		10. 大小比较( >/ >=/ </ <=) 
		11. 双目运算符(|| && <= == !=)
		12. 注意: 语法分析使用本次作业提供的文法, 即文件“grammar.txt”. 文法规则格式如下: [产生式头部] [空格] -> [空格] [产生式体]
		13. 注: 文法中出现的$代表ε. 文法中出现的 IDN(标识符), INT(整数)参照词法分析器中定义. 所有的关键字, 界符, 运算符均以原本形式存在, 即终结符就是词法分析器中定义的形式. 
	2. 流程说明: 以 LL(1)语法分析方法为例, 构建语法分析器需要完成以下内容: 
		1. 求FIRST 集合, FOLLOW 集合
		2. 匹配对待编译代码规约使用的产生式序列. 
		3. 实现语言: C/C++/Java/Python. 注意: 中端代码为 C++编写, 若决定做选做部分,  推荐首选 C++. 
		4. 输出: 请严格按照第三章“输出示例”的格式要求, 将结果保存为文本文件(.txt). 
	
3. 中间代码生成(选做)
	1. LLVM IR 具有三种表示形式, 这三种中间格式是完全等价的: 
		1. 在内存中的编译中间语言(我们无法通过文件的形式得到)
		2. 在硬盘上存储的二进制中间语言(格式为 .bc)
		3. 人类可读的代码语言(格式为 .ll) 本次实验要求输出 .ll 形式的 LLVM IR. 
	2. 中间代码生成器代码补全: 对给出的中间代码生成器部分代码的缺失部分, 即各个结点的 visitor 函数进行补全. 针对每个结点构造一个 visitor 函数来调用中端代码类(见附录1.2), 其中 visit 函数对应于图一中语法分析和中间代码生成的衔接部分. 
	3. 实现语言: C++；
	4. 操作目的: 完成对语法分析生成的抽象语法树的遍历, 并通过访问语法树结点来调用我们提供的中端代码(见附录 1.2), 生成 LLVM IR 中间代码. 
